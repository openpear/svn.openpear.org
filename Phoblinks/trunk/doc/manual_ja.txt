.. -*- coding: utf-8 -*-

=========================
        Phoblinks
=========================

.. |date| date::

:著者: 鈴木鉄也 <suzuki@spice-of-life.net>
:日付: |date|
:バージョン: Phoblinks 0.7

.. _English: manual_en.html

.. contents::

..


--------------------
        概要
--------------------

PhoblinksはPHP5のオブジェクトシステムを拡張するライブラリです。
SmalltalkとObjective-Cを中心として、
Ruby, Python, CLOSなどの言語と、
Cocoa, WebObjects, Mooseなどのフレームワークやライブラリを参考にしています。

Phoblinksは次の機能を提供します。

* **クラスオブジェクト。**
  Phoblinksでは、クラスもまたオブジェクトです。
  PHPにはないクラスメソッドを実装できるほか、
  クラスインスタンス変数を定義することができます。
* **プロパティの管理。**
  オブジェクトのプロパティの仕様を設定でき、
  その仕様を元にアクセサメソッドを生成します。
* **トレイト。**
  トレイト (Traits) は任意のクラスにメソッド実装を提供する仕組みです。
  ミックスインと異なり、トレイトはクラスの継承階層に影響しません。
* **補助メソッド。**
  補助メソッドは、メソッド実行の前後にフックとして実行されるメソッドです。
  元のメソッドを変更せずにフックをかけることができます。


メソッド名の表記について
========================

Phoblinksではメソッド名の表記について、
クラスメソッドならば ``+`` 、インスタンスメソッドならば ``-`` を
メソッド名の先頭につけることにしています
（この表記はObjective-Cから採りました）。
``PhobObject`` のインスタンスメソッド ``isEqual()`` であれば
``-[PhobObject isEqual()]`` 、
``PhobClass`` のクラスメソッド ``name()`` であれば
``+[PhobClass name()]`` などと表します。


------------------------------------
        オブジェクトとクラス
------------------------------------

PHPやPhoblinksで言うオブジェクトとは、何らかのクラスのインスタンスになります。
Phoblinksのオブジェクトはすべて、
``PhobObject`` クラス（のサブクラス）のインスタンスです。

ただしPHPでは、クラスそのものはオブジェクトではありません。
クラスを指定する必要のある関数やメソッドでは、
クラス名の文字列を引数として受け付けます。

Phoblinksでは、クラスもオブジェクトとして扱います
（クラスも何らかのクラスのインスタンスということになりますが、
クラスのクラスのことをメタクラスと呼びます）。
オブジェクトということはメソッドを持ちますから、
クラスも自分のメソッドを持てることになります。
これがクラスメソッドとなります。

PHPには静的メソッドがありますが、これはクラスメソッドではありません。
静的メソッドにはレシーバ (``$this`` に相当する) がなく、継承もできません。
``self`` の指すクラス名は実装時のクラス名に固定されてしまいます。

例えば、Phoblinksのクラスにはクラス名を返す ``name()`` という
クラスメソッドが定義されています。
これと同じことを静的メソッドでやろうと思えば、次のようなコードを書くでしょう。

::

 class MyClass
 {
     static function name()
     {
         return get_class(new self);
     }
 }

しかし、この ``name()`` が意図通りに動作するのは ``MyClass`` に限ります。
``MyClass`` のサブクラスを定義して ``name()`` を呼び出してみると、
結果は ``MyClass`` のままです。
静的メソッドは呼び出し元のサブクラスの情報を持たず、
``self`` の内容は静的に決まるので、継承させることはできません。

::

 class NewMyClass extends MyClass {}
 print NewMyClass::name(); //=> "MyClass"

Phoblinksではクラスもオブジェクトとして扱うことで、
オブジェクトを中心とするプログラミングを
より広い範囲で行うことができるようになります。


----------------------------
        クラスの定義
----------------------------

クラスの定義
============

クラスビルダ
------------

Phoblinksクラスの定義は、クラスビルダとPHPクラス定義で構成されます。
クラスビルダはクラスの設定と生成を行うオブジェクトで、
``+[Phoblinks toDefineClass()]`` で生成できます。

まずは次の簡単な例を見てください
（このコードはサンプルの ``BankAccount.php`` のものです）。

``BankAccount`` クラス::

 // クラスビルダを生成する。
 $cls = Phoblinks()->toDefineClass('BankAccount');

 // プロパティを設定する。
 $cls->property('ballance')
     ->defaultValue(0);

 // クラス定義開始
 $cls->begin(); // BankAccount

 class BankAccount extends PhobObject
 {

     function deposit($x)
     {
         $this->_ballance += $x;
     }

     function withdraw($x)
     {
         $this->_ballance = max(array(0, $this->_ballance-$x));
     }

 }

 // クラス定義終了
 $cls->end(); // BankAccount

最初に ``+[Phoblinks toDefineClass()]`` でクラスビルダを生成します。
このクラスビルダにクラスの様々な情報を設定していき、
最後にPhoblinksクラスを生成します。
``+toDefineClass()`` では定義するクラス名とスーパークラス
（Phoblinksクラスオブジェクト）を指定します。
スーパークラスを省略すると、 ``PhobObject`` を指定したことになります。

次のコードはプロパティの設定です。
Phoblinksはプロパティの設定に応じたアクセサメソッドを生成します。
ここでは初期値が ``0`` の ``ballance`` プロパティを指定しています。
デフォルトの設定では、プロパティ値にはアンダーバーつきのフィールド名で
アクセスすることができます。
``ballance`` プロパティなら ``$this->_ballance`` となります。

必要な設定を終えたらPHPクラスを定義し、その前後をクラスビルダの
``-begin()`` と ``-end()`` の呼び出しで囲みます。
PHPクラスのスーパークラスには、
クラスビルダで指定したスーパークラスと同じクラスを指定します。

最後の ``-end()`` の呼び出しで、
Phoblinksクラスオブジェクトが生成され、登録されます。
以降はクラスと同名の関数（ ``BankAccount`` クラスなら ``BankAccount()`` ）
でクラスオブジェクトを取得できます。

さらにPHPクラスのサブクラスが一つ定義され、
そのクラスにプロパティのアクセサメソッドとトレイトのメソッドが実装されます。
このサブクラスをラッパークラスと呼ぶことにします。
ラッパークラスの名前はクラス名の前後に ``__`` をつけたもので、
``BankAccount`` なら ``__BankAccount__`` となります。
``BankAccount`` のサブクラスのPHPクラス定義では、
このラッパークラスを継承する必要があります
（Phoblinksライブラリのクラスにはラッパークラスはありません）。
次に ``BankAccount`` クラスのサブクラスの例を示します。

``StockAccount`` クラス::

 $cls = Phoblinks()->toDefineClass('StockAccount', BankAccount());
 ...
 $cls->begin(); // StockAccount

 class StockAccount extends __BankAccount__
 {
     ...
 }

 $cls->end(); // StockAccount

スーパークラスに ``BankAccount`` クラスオブジェクトを、
PHPクラス定義のスーパークラスに ``__BankAccount__`` を指定しています。
``BankAccount`` を継承するとエラーになります。


クラスメソッドの定義
--------------------

クラスメソッドは「 ``ClassOf`` + クラス名」のPHPクラスで定義できます。
このPHPクラスは、インスタンスメソッドを定義するPHPクラスと
同じクラスの ``ClassOf...`` クラスを継承しなければいけません。

先の ``BankAccount`` クラスであれば、
``BankAccount`` クラスは``PhobObject`` を継承しているので
``ClassOfBankAccount`` クラスは ``ClassOfPhobObject``
を継承しなければいけません。

::

 class ClassOfBankAccount extends ClassOfPhobObject
 {
     ...
 }

::

 class ClassOfStockAccount extends __ClassOfBankAccount__
 {
     ...
 }


まとめ
----------------

まとめると、クラス定義の手順は次のようになります。

1. ``+[Phoblinks toDefineClass()]`` でクラスビルダを生成する。
2. プロパティなどのクラス情報を設定する。
3. クラスビルダの ``-begin()`` メソッドを呼ぶ。
4. PHPクラスを定義する。
5. クラスビルダの ``-end()`` メソッドを呼ぶ。

クラス定義するとこうなります。

* クラスオブジェクトを返す、クラスと同名の関数が定義されます。
* アクセサメソッドやトレイトのメソッドを追加したラッパークラスが定義されます。
  ラッパークラスの名前は、デフォルトでは元のクラス名の前後に
  ``__`` がつきます。
  サブクラスのPHPクラス定義をするときに、このラッパークラスを指定します。
  ただし、Phoblinksライブラリなどラッパークラスがないクラスもあります。


--------------------------
        プロパティ
--------------------------

概要
====

オブジェクトのプロパティの準備には手間がかかります。
大抵の場合は、フィールド宣言に加えて
アクセサメソッドを実装することが多いでしょう。
外部ストレージにオブジェクトを保存したければ、
プロパティ値を検証するメソッドと、
プロパティ値をストレージに保存できるよう変形するメソッドを
実装する必要があります。
PHPらしく複数の型の値をセッターで受け取りたいこともあるでしょうし、
初期値の代入を要求があるまで遅らせたいこともあるでしょう。
Phoblinksでは、プロパティを宣言することで多くの手間を省くことができます。
次にプロパティを宣言する利点を示します。

* **フィールドの宣言。**
  プロパティ値を保持するフィールドを宣言します。
* **アクセサメソッドの生成。**
  プロパティ値の読み書きを行うメソッドを生成します。
  セッターは代入値の変形と検証を行います。
  変形と検証にはそれぞれ値変形器 (PhobValueTransformer) と値検証器 (PhobValueValidator) を使います。
* **初期値の準備。**
  オブジェクトの初期化時、プロパティのフィールドに初期値を代入します。
  初期値を代入するタイミングを遅らせることもできます。
* **代入値の変形。**
  セッターで代入値を任意の値に変形できます。
* **代入値の検証。**
  セッターで代入値を検証できます。


プロパティの設定
================

プロパティの設定はクラスビルダで行います。
``property($name)`` でプロパティビルダを生成し、必要な設定を行います。
クラスビルダと同様に、メソッドは連鎖可能です。


基本的な設定
------------

``valueType($type)``
  プロパティ値の型名を指定します。
  セッターを使って異なる型を代入しようとすると例外を投げます。

``memberName($name)``
  プロパティのフィールド名を指定します。
  デフォルトはプロパティ名の先頭にアンダースコアをつけた名前です。
  ``name`` プロパティならフィールド名は ``_name`` になります。

``allowsNull($flag=true)``
  真ならプロパティ値に ``null`` を許します。
  偽であれば、代入値が厳密に ``null`` の場合に例外を投げます。

``accessors($rw)``
  生成するアクセサメソッドを文字列で指定します。
  "r" ならゲッターのみ、 "w" ならセッターのみ、 "rw" なら両方を生成します。


初期値の設定
------------

``defaultValue($value)``
  初期値を指定します。
  初期値はオブジェクトの初期化時にフィールドに代入されます。

``defaultValueInitializer($init)``
  初期値を生成するソースコードを指定します。
  このソースコードは無名関数として定義され、
  オブジェクトの引数を一つ受け取ります。
  代入する初期値は必ず ``return`` で返す必要があります。

``delaysDefaultValueInitialization($flag=true)``
  真であれば、初期値の代入をゲッターの呼び出しまで遅らせます。

その他の設定
------------

``trait($trait)``
  トレイトを指定します。

``auxiliaryMethodForMethod($meth, $modifier, $primary)``
  補助メソッドを指定します。引数は先頭から補助メソッド名、
  メソッド修飾子、主メソッド名です。

``valueTransformerName($name)``
  値変形器の名前を指定します。

``valueValidator($validator)``
  値検証器を指定します。
  値検証器は複数指定することができます。


セッターメソッドの処理の流れ
============================

セッターメソッドの処理の流れを次に示します。

1. 値変形器を使って代入値を変形します。
2. 値検証器を使って代入値を検証します。
   エラーがあれば例外を投げます。
3. プロパティの設定に基づいて代入値を検証します。
   エラーがあれば例外を投げます。
4. 代入値をフィールドに代入します。


値変形器
========

値変形器 (PhobValueTransformer) は、与えられた値を任意の値に変形するオブジェクトです。
プロパティのセッターメソッドで使われますが、特定のプロパティやクラスに依存せず、汎用的に使えます。

値変形器は名前をつけて登録することができ、
プロパティで使う値変形器はプロパティビルダの ``valueTransformerName($name)`` で名前を指定します。


用意済みの値変形器
------------------

``PhobValueTransformer::NegativeBooleanTransformerName``
''''''''''''''''''''''''''''''''''''''''''''''''''''''''

真偽値を逆にして返します。
引数が真偽値でなければ、真偽値にキャストしてから逆にして返します。

``PhobValueTransformer::IsNullTransformerName``
'''''''''''''''''''''''''''''''''''''''''''''''

引数が ``null`` であれば真を、そうでなければ偽を返します。

``PhobValueTransformer::IsNotNullTransformerName``
''''''''''''''''''''''''''''''''''''''''''''''''''

引数が ``null`` でなければ真を、そうでなければ偽を返します。


値変形器の実装と登録
--------------------

PhobValueTranformerのサブクラスを定義し、値を変形する ``transformedValue($value)`` メソッドを実装します。
そのインスタンスを ``+[PhobValueTransformer setValueTransformerForName($transformer, $name)]`` 
で名前をつけて登録します。
登録した値変形器は ``+valueTransformerForName($name)`` で取得できます。


値検証器
========

値検証器 (``PhobValueValidator``) は、与えられた値が任意の制約に
従っているかどうかを検証するオブジェクトです。
値が制約に従っていない場合、制約に合わせて値を変えるか
検証エラーの例外を投げるかします。
値変形器と同様に、プロパティ以外にも汎用的に使えます。

値変形器と異なるのは、制約条件を設定できることです。
メールアドレスの長さやフォーマットを検査したり、
商品価格の最小値を制限するなどができます。


値検証器の使用
--------------

値検証器はプロパティビルダの ``valueValidator($validator)`` で指定します。
値検証器は複数指定できます。
複数の値検証器を使う場合は ``valueValidator()`` を回数分呼びます。
次に例を示します。

::

 // 文字列用の値検証器の生成
 $strValidator = PhobStringValueValidator()->make();
 $strValidator->setAllowsEmpty(false);
 $strValidator->setMaximumLength(255);

 // プロパティにセット
 $cls->property('name')
     ->valueValidator($strValidator);


用意済みの値検証器
------------------

``PhobStringValueValidator``
''''''''''''''''''''''''''''

文字列のプロパティを検証します。

``allowsEmpty()``, ``setAllowsEmpty($flag)``
  真であれば空文字列の代入を許可します。
  偽であれば空文字列を代入しようとすると例外を投げます。

``maximumLength``, ``setMaximumLength($value)``
  文字列の最大の長さです。
  代入する文字列の長さがこの値より大きければ例外を投げます。
  最大長を指定しない場合は負の数を指定してください。

``minimumLength``, ``setminimumLength($value)``
  文字列の最小の長さです。
  代入する文字列の長さがこの値より小さければ例外を投げます。
  最小長を指定しない場合は負の数を指定してください。


値検証器の実装
--------------

``PhobValueValidator`` クラスのサブクラスを定義し、
``validateValue($value)`` メソッドを実装します。
引数の値が制約に従っていなければ、値を制約に収まるように変更して返すか
例外 ``PhobValidationException`` を投げてください。


----------------------------------------
        プロパティのカスタマイズ
----------------------------------------


プロパティビルダの作成
======================

プロパティビルダの役割
----------------------

プロパティビルダは、プロパティの生成に必要な次の機能を提供します。

* プロパティの設定を行います。
* プロパティクラスを提供します。
* プロパティ値のアクセサメソッドを生成します。


流れるようなインターフェース
----------------------------

``+[Phoblinks toDefineClass()]`` で生成できるクラスビルダと、
そのクラスビルダが返すプロパティビルダは、
実際には「流れるようなインターフェース (fluent interface) 」を
備えた各ビルダのラッパーです。
各メソッドの戻り値がラッパー自身になるので
ビルダの設定を続けて行うことができ、
メソッドには ``set`` などの接頭辞も不要です。

このラッパーは、呼ばれたメソッドの名前から
次に示すビルダのアクセサメソッドを探して実行します。

``set`` + メソッド名
  メソッド名の先頭の文字を大文字にし、接頭辞に ``set`` をつけたメソッドを
  ビルダから探して実行します。
  ``$wrapper->valueType(...)`` なら ``$builder->setValueType(...)``
  を実行します。
  メソッド名が ``is`` で始まる場合のみ、 ``is``
  を省略したセッターも探します。
  ``isOptional`` なら ``setIsOptional`` に加えて ``setOptional`` も有効です。

``add`` + メソッド名
  メソッド名の先頭の文字を大文字にし、接頭辞に ``add`` をつけたメソッドを
  ビルダから探して実行します。
 

プロパティビルダの作成
----------------------

``PhobPropertyBuilder`` クラスのサブクラスを定義し、
プロパティに必要な設定のアクセサメソッドを実装します。
デフォルト以外のプロパティクラスを使うならば、
``-propertyClass()`` をオーバーライドして
使用するプロパティクラスを返すようにします。


プロパティビルダクラスの登録
----------------------------

新しく作ったプロパティビルダクラスは、
``+[PhobClassBuilder setPropertyBuilderClassForName($class, $name)]``
メソッドで名前をつけて登録する必要があります。
あとはクラスビルダでプロパティを作成するときに
``property($name, $builderName)`` の二番目の引数に登録した名前を
指定すれば、新しいプロパティビルダを使えるようになります。



プロパティクラスの作成
======================

``PhobProperty`` クラスのサブクラスを定義し、
``-initWithPropertyBuilder($builder, $owner)``
メソッドをオーバーライドします。
引数の ``$builder`` はプロパティビルダ、 ``$owner``
はプロパティの所属するクラスです。
プロパティビルダを使って必要な初期化を行ってください。



-----------------------------
        補助メソッド
-----------------------------

補助メソッド (auxiliary method) は、
メソッドの実行前後にフックとして実行されるメソッドです。
このフックの対象となるメソッドを主メソッド (primary method) と呼びます。

次の例は、 ``sayHello`` メソッドの前後に補助メソッドを実行します。
``sayHello()`` の実行前に ``willSayHello()`` が、
実行後に ``didSayHello()`` が実行されます。


::

 $cls = Phoblinks()->toDefineClass('NewClass')
     ->auxiliaryMethod('willSayHello', 'before', 'sayHello')
     ->auxiliaryMethod('didSayHello', 'after', 'sayHello');
     ->begin();

 class NewClass extends PhobObject
 {
     function willSayHello()
     {
         print "=== Begin sayHello()\n";
     }

     function sayHello()
     {
         print "Hello, world!\n";
     }

     function sayHello()
     {
         print "=== Did sayHello()\n";
     }
 }

 $cls->end();

 === Begin sayHello()
 Hello, world!
 === Did sayHello()


補助メソッドの指定
==================

補助メソッドを指定するには、クラス定義時に
``auxiliaryMethod($auxMeth, $modifier, $primMeth)``
メソッドに必要な引数を渡します。
``$auxMeth`` が補助メソッド名、 ``$modifier`` がメソッド修飾子、
``$primMeth`` が主メソッド名です。

現在、主にパフォーマンス上の理由から、一度決定した補助メソッドは変更できません。


メソッド修飾子
==============

メソッド修飾子には次のものがあります。

``before``
  主メソッドの実行前に実行されます。
  戻り値は主メソッドのものになります。

``after``
  主メソッドの実行後に実行されます。
  戻り値は主メソッドのものになります。

``around``
  主メソッドの代わりに実行され、戻り値も補助メソッドのものになります。
  主メソッドは実行されません。


------------------------------------------
        オブジェクトの生成と初期化
------------------------------------------

オブジェクトの生成と初期化
==========================

Phoblinksでは、オブジェクトの生成と初期化を分けて行います。
オブジェクトの生成には ``new`` 演算子の代わりに
``+alloc()`` メソッドを使い、 ``-init`` とつくメソッドで初期化をします。
そのため、通常は ``+alloc()`` と ``-init...()``
の一連の処理を続けて行います。

``+alloc()`` で生成されるオブジェクトは、
空のコンストラクタで ``new`` されたものと同じです。
クラス以外のプロパティ値はセットされていません。

オブジェクトの生成と初期化の例::

 $obj = PhobObject()->alloc()->init();

``+alloc()`` と ``-init()`` の組み合わせを使う場合に限り、
``+make()`` を省略形として使えます
（本当は ``+new()`` にしたかったのですが、予約語の都合で
``new`` をメソッド名に使うことはできません）。


初期化メソッドの実装
====================

Phoblinksではオブジェクトの生成と初期化を分けて行うので、
必要なだけ初期化メソッドを用意できます。
最も基本的な初期化メソッドは、デフォルトで用意されている ``-init()`` です。
すべての初期化メソッドでは必ず ``-init()`` を実行しなければいけません。
その際、 ``-init()`` 以外の初期化メソッドでは ``parent::init()`` ではなく
``$this->init()`` を呼んでください。
これはラッパークラスの ``init()`` でプロパティ値の初期化が行われるためです。

初期化メソッドの名前は自由につけて構いませんが、
``init`` で始まる名前を推奨します。
引数が名前を表す値であれば ``initWithName()`` などとします。

注意: ``new`` 演算子はPhoblinks内部で使われるので、
通常のコンストラクタメソッド (``__construct``)
をオーバーライドしないでください。


---------------------------------
        トレイト (Traits)
---------------------------------

トレイトとは何か
================

トレイトとは、任意のクラスに追加できるメソッドの集合です。
PhoblinksではトレイトもPHPのクラスとして定義しますが、
そのクラスをインスタンス化することはありません。
クラスの定義時にトレイトを指定することで、
そのトレイトのメソッドをクラスにコピーできます。
ミックスインと異なり、トレイトはクラスの継承階層に影響しません。
トレイトは純粋にメソッドの実装をクラスに追加するだけです。

次のコードは、標準出力に自身の情報を出力するメソッド ``inspect()`` を持つ
トレイトの定義です。
このトレイトをクラスビルダで指定すると、そのクラスのインスタンスで
``inspect()`` メソッドが使えるようになります。
``Inspecting`` トレイトはPHPクラスとして定義されていますが、
このトレイトを使うクラスの継承階層に
``Inspecting`` クラスが入ることはありません。

::

 class Inspecting
 {
     static function inspect($self)
     {
         var_dump($self);
     }
 }

 Phoblinks()->defineTrait('Inspecting');


トレイトの定義
==============

トレイトは次の手順で定義します。

1. PHPクラスを定義します。
2. トレイトメソッドを静的メソッドで定義します。
3. ``Phoblinks`` オブジェクトに登録する。

先の例をもう一度見てみます。

::

 class Inspecting
 {
     static function inspect($self)
     {
         var_dump($self);
     }
 }

 Phoblinks()->defineTrait('Inspecting');

``Inspecting`` クラスは静的メソッド ``inspect()`` を定義しています。
この静的メソッドが、このトレイトを使うクラスから呼ばれます。
トレイトを使うクラスのインスタンスは、
最初の引数をそのインスタンスにして静的メソッドを呼び出します。
そのため静的メソッドには最低一つの引数が必要です。
この引数名に ``$this`` は使えないので、適当な名前に変えてください。

クラスを定義したら、そのクラス名を引数にして
``+[Phoblinks defineTrait()]`` を呼びます。
そのクラス名と同名のトレイトオブジェクトと、
トレイトオブジェクトを返す同名の関数が定義されます。
この例では、 ``Inspecting()`` 関数で ``Inspecting``
トレイトを取得できるようになります。


トレイトの使用
==============

クラスビルダの ``trait()`` メソッドでトレイトを指定します。
一つのクラスに指定できるトレイトは一つです。
複数のトレイトを使いたい場合は、合成して一つのトレイトにします。
次に例を示します。

::

 $cls->Phoblinks()->toDefineClass('NewClass');
 $cls->trait($trait);


トレイトの合成とカスタマイズ
============================

複数のトレイトを足したり、必要なメソッドを個別に選ぶことで
新しいトレイトを作ることができます。


変更可能なトレイト
------------------

新しく生成したトレイトや、 ``traitByUnioningTrait()`` か
``traitByMinusingTrait($trait)`` で返されるトレイトは変更可能です。
これらのトレイトは ``Phoblinks`` オブジェクトに登録されるか
新しいクラスで使われると変更不可になり、メソッドの編集ができなくなります。


トレイトの生成
--------------

``init()``
  トレイトを初期化します。
  トレイトの名前とメソッドは空です。

``initWithName($name, $meths)``
  トレイト名とメソッドの配列でトレイトを初期化します。

``copy()``
  レシーバのトレイトと同じメソッドを持つ、新しいトレイトを生成して返します。

``setName($name)``
  トレイト名を変更します。


トレイト同士の演算
------------------

二つのトレイトを演算して、新しいトレイトを作ることができます。

``unionTrait($trait)``
  レシーバのトレイトに引数のトレイトのメソッドをすべて足します。
  トレイトが変更不可になっているか、メソッドが重複すると例外を投げます。

``traitByUnioningTrait($trait)``
  両トレイトのメソッドをすべて含む、新しいトレイトを生成して返します。
  トレイトのメソッドが重複すると例外を投げます。

``minusTrait($trait)``
  レシーバのトレイトから、
  引数のトレイトと重複するメソッドを取り除きます。
  トレイトが変更不可であれば例外を投げます。

``traitByMinusingTrait($trait)``
  レシーバのトレイトのメソッドのうち、
  引数のトレイトのものと重複しないメソッドを持つ
  新しいトレイトを生成して返します。


メソッドの編集
--------------

次のメソッドで、トレイトのメソッドを編集できます。
どの操作もトレイトが変更不可であれば例外を投げます。

``addMethod($className, $methName, $rename=null)``
  トレイトにメソッドを追加します。 ``$className`` は追加するメソッドのクラス名、
  ``$methName`` は追加するメソッドです。
  トレイトのメソッド名を変更したい場合は ``$rename`` を指定します。

``removeMethodForName($name)``
  トレイトからメソッドを取り除きます。

``renameMethod($name, $replace)``
  トレイトのメソッド名を変更します。


トレイトの登録
--------------

トレイトを登録すると、そのトレイトを取得するための同名の関数が定義されます。
登録は ``+[Phoblinks addTrait($trait)]`` で行います。
登録前に ``setName($name)`` でトレイト名を設定してください。


競合するメソッドの解決
----------------------

トレイト同士を加算したりメソッドを追加するなどして、
新しいトレイトのメソッドに重複があるとエラーになります。
その場合は、重複したメソッドを取り除くか名前を変えてください。

